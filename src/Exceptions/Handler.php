<?php

namespace Kirago\BusinessCore\Exceptions;

use Illuminate\Auth\AuthenticationException;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Illuminate\Http\Request;
use Illuminate\Session\TokenMismatchException;
use Illuminate\Support\Arr;
use Illuminate\Validation\ValidationException;
use Neomerx\JsonApi\Exceptions\JsonApiException;
use Spatie\Permission\Exceptions\UnauthorizedException as SpatiePermissionException;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Throwable;


class Handler extends ExceptionHandler
{
    /**
     * The list of the inputs that are never flashed to the session on validation exceptions.
     *
     * @var array<int, string>
     */
    protected $dontFlash = [
        'current_password',
        'password',
        'password_confirmation',
    ];

    /**
     * A list of the exception types that are not reported.
     *
     * @var array<int, class-string<Throwable>>
     */
    protected $dontReport = [
        JsonApiException::class,
    ];

    public function report(Throwable $e)
    {
        parent::report($e); // TODO: Change the autogenerated stub
    }

    /**
     * Register the exception handling callbacks for the application.
     */
    public function register(): void {
        $this->renderable(function (\Exception $exception, Request $request) {

            $instance = get_class($exception); // "\Spatie\Permission\Exceptions\UnauthorizedException"
            $response = ["message" => "Erreur" , 'success' => false];
            //  $status = $exception->getCode();



            if ($exception instanceof ValidationException){
                  $response['errors'] = Arr::map(
                                          $exception->validator->errors()->messages(),
                                          fn($error,$key) =>  $error[0]
                                      );
            }

            $code = $exception?->getCode();

            $status = match($instance) {
                        NotFoundHttpException::class, ModelNotFoundException::class => Response::HTTP_NOT_FOUND,
                        AuthenticationException::class => Response::HTTP_UNAUTHORIZED,
                        TokenMismatchException::class => Response::HTTP_CONFLICT,
                        AccessDeniedHttpException::class,SpatiePermissionException::class => Response::HTTP_FORBIDDEN,
                        ValidationException::class => Response::HTTP_UNPROCESSABLE_ENTITY,
                        default => (is_numeric($code) && $code != 0) ? $code : Response::HTTP_INTERNAL_SERVER_ERROR
                    };

            $getMessage = function ($message) use ($exception){
                                return app()->isLocal() ? $exception->getMessage() : $message;
                            };

            $message = match($instance) {
                NotFoundHttpException::class,ModelNotFoundException::class => $getMessage("La page/ressource que vous demandez n'existe pas ou a été supprimé."),
                            AuthenticationException::class => $getMessage("Vous devez vous connecté pour continuer."),
                            \Illuminate\Database\QueryException::class => $getMessage("Erreur fatale dans les données."),
                            default =>  $getMessage("Une erreur imprévue est survenue lors de la demande")
                      };

            // dd($status,get_class($exception),$exception->getMessage());

            if ($request->ajax() or $request->wantsJson() or  $request->is('api/*')){
                $response['message'] = $message;

                if (app()->isLocal()){
                    $response['exception'] = format_exception_message($exception);
                    $response['trace'] = $exception->getTraceAsString();
                }
                return response()->json($response, $status);
            }
        });
    }
}
